-- Get addon table.
local PowerAuras = select(2, ...);

--- Table storage system.
local TableStore = setmetatable(PowerAuras:CopyTable(table), { __mode = "v" });

--- Classes (covered at bottom of file).
local BufferStateClass, ResourceDataClass;

--- Buffer state objects by frame index. 1 is the current frame, 2 is the next,
--  and so on up until MAX_STATE_BUFFERS.
local BuffersByFrame = {};

--- Dictionary of trigger types and a delay for rechecking all triggers of
--  the specified type.
local DelayTypes = {};

--- Dictionary of actions and their dispatcher data tables.
local DispatcherActionIDsData = {};
local DispatcherActionsData = {};

--- Sequential list of actions to process. Sorted with dependencies resolved.
local DispatcherActionsList = {};

--- Dictionary of displays and their dispatcher data tables.
local DispatcherDisplayIDsData = {};
local DispatcherDisplaysData = {};

--- Load state for the dispatcher.
local DispatcherLoaded = false;

--- Dictionary of providers and their dispatcher data tables.
local DispatcherProviderIDsData = {};
local DispatcherProvidersData = {};

--- Sequential list of providers to process. Providers don't have dependencies!
local DispatcherProvidersList = {};

--- True if currently in editing mode, false if not.
local EditMode = false;

--- Reference to the active buffer used for events.
local EventBuffer = nil;

--- Collection of filters for the OnEvent function. Generated by LoadEvents.
local EventFilters = {};

--- Event handler function.
-- @param frame The owning frame.
-- @param event The fired event.
-- @param ...   Event arguments.
local function OnEvent(frame, event, ...)
	-- Assume we're capturing this event.
	local filter = EventFilters[event];
	if(not filter) then
		return;
	end
	-- Get the current buffer.
	local buffer = EventBuffer;
	-- Iterate over the filter data.
	local trig, act, prov, cust = filter[1], filter[2], filter[3], filter[4];
	-- Flag trigger types.
	for i = trig, act - 1 do
		buffer.Triggers[filter[i]] = true;
	end
	-- Flag actions.
	for i = act, prov - 1 do
		buffer.Actions[filter[i]] = true;
	end
	-- Flag providers.
	for i = prov, cust - 1 do
		local prov = filter[i];
		-- Slighly more complex, so make sure it's not already flagged.
		if(not buffer.Providers[prov]) then
			buffer.Providers[prov] = true;
			-- In addition, flag the actions that need this provider.
			local data = DispatcherProvidersData[prov];
			for j = 1, #(data.ActionDeps) do
				buffer.Actions[data.ActionDeps[j]] = true;
			end
		end
	end
	-- Run custom filters (triggers).
	for i = cust, #(filter) do
		filter[i](buffer, ...);
	end
	-- Reset logged event flag.
	buffer.IsEventLogged = false;
end

--- OnUpdate script handler. Processes all queued events and updates all
--  actions that need an update.
local function OnUpdate()
	-- Ensure the event environment is pointing to the next buffer.
	EventBuffer = BuffersByFrame[2];
	-- Get the buffer.
	local buffer = BuffersByFrame[1];
	local time = buffer.Time;
	-- Cycle through actions.
	local count, progress = #(DispatcherActionsList), buffer.ActionProgress;
	local limit = PowerAuras.GlobalSettings["ActionsPerFrame"];
	for i = progress, count do
		-- Get the action and our data on it.
		local action = DispatcherActionsList[i];
		local data = DispatcherActionsData[action];
		-- Check for activation.
		if(buffer.Actions[action] or data.Timed) then
			action(buffer, data.Sequence);
		elseif(data.Delay and data.Delay <= time) then
			action(buffer, data.Sequence);
			data.Delay = nil;
		else
			-- Try trigger types. The event handler is quite smart, so this is
			-- only tried as a last resort.
			local types = data.Types;
			local triggers = buffer.Triggers;
			for j = 1, #(types) do
				if(triggers[types[j]]) then
					action(buffer, data.Sequence);
					break;
				end
			end
		end
		-- Break early if needed.
		if((progress % limit) == 0) then
			buffer.ActionProgress = progress + 1;
			return;
		end
	end
	-- Update stored progress.
	buffer.ActionProgress = progress + 1;
	-- Cycle through providers.
	local count, progress = #(DispatcherProvidersList), buffer.ProviderProgress;
	local limit = PowerAuras.GlobalSettings["ProvidersPerFrame"];
	for i = progress, count do
		-- Get the provider and our data.
		local prov = DispatcherProvidersList[i];
		local data = DispatcherProvidersData[prov];
		-- Need to update resources?
		if(buffer.Providers[prov]) then
			local resources = data.ResourceDeps;
			for i = 1, #(resources) do
				resources[i]:OnProviderUpdate();
			end
		end
		-- Break early if needed.
		if((progress % limit) == 0) then
			buffer.ProviderProgress = progress + 1;
			return;
		end
	end
	-- Update stored progress.
	buffer.ProviderProgress = progress + 1;
	-- Cycle buffers if we hit this point. Don't swap the buffer used by
	-- OnEvent, as that one will be the one we're swapping in. Deferring it
	-- until the start of the next frame so that any final events are handled
	-- ASAP.
	PowerAuras:SwapBuffers();
end

--- Returns the currently active sequence of an action.
-- @param id The ID of the action.
function PowerAuras:GetActionActivationSequence(id)
	local data = DispatcherActionIDsData[id];
	return (data and data.Sequence or nil);
end

--- Returns the activation state of an action.
-- @param id The ID of the action.
function PowerAuras:GetActionActivationState(id)
	local data = DispatcherActionIDsData[id];
	return (data and data.State or false);
end

--- Returns the time when an action was initially activated.
-- @param id The ID of the action.
function PowerAuras:GetActionActivationTime(id)
	local data = DispatcherActionIDsData[id];
	return (data and data.Time or nil);
end

--- Returns the time at which the specified action will be rechecked for
--  activation, or nil if no delay has been set.
-- @param id The ID of the display.
-- @return A time in the future based on GetTime(), or nil if no delay
--         is active.
function PowerAuras:GetActionRecheckDelay(id)
	local data = DispatcherActionIDsData[id];
	return (data and data.Delay or nil);
end

--- Returns the activation/showing state of a display.
-- @param id The ID of the display.
function PowerAuras:GetDisplayActivationState(id)
	local data = DispatcherDisplayIDsData[id];
	return (data and data.State or DisplayStates["Hide"]);
end

--- Returns the edit mode state of the dispatcher.
function PowerAuras:GetEditMode()
	return EditMode;
end

--- Returns the stored data owned by a trigger.
-- @param id    The ID of the action.
-- @param index The index of the trigger.
function PowerAuras:GetTriggerStore(id, index)
	local data = DispatcherActionIDsData[id];
	data = (data and data.Triggers[index] or nil);
	return (data and data.Store or nil);
end

--- Returns true/false if the specified trigger needs timed rechecks.
-- @param id    The ID of the action.
-- @param index The index of the trigger.
function PowerAuras:GetTriggerTimed(id, index)
	local data = DispatcherActionIDsData[id];
	data = (data and data.Triggers[index] or nil);
	if(data) then
		return data.Timed;
	else
		return nil;
	end
end

--- Returns the time at which the specified trigger type will be queued for
--  rechecking, or nil if no delay has been set.
-- @param type The type of trigger.
-- @return A time in the future based on GetTime(), or nil if no delay
--         is active.
function PowerAuras:GetTriggerTypeRecheckDelay(type)
	return DelayTypes[type];
end

--- Returns true if the dispatcher is currently loaded.
function PowerAuras:IsDispatcherLoaded()
	return DispatcherLoaded;
end

do
	--- Temporary tables. Used for a lot of things.
	local temp, temp2 = {}, {};

	--- Returns a table containing all the dependencies of an action.
	-- @param self The PowerAuras table reference.
	-- @param id   The ID of the action.
	-- @remarks Returns temp2 as the table.
	local function GetActionDependencies(self, id)
		-- Clean temporary table.
		wipe(temp2);
		-- Get the dependencies of the action as an immediate priority.
		local loadData = self:GetLoadedActionData(id);
		for dep, _ in pairs(loadData.Actions) do
			temp2[dep] = true;
		end
		-- Handle display dependencies.
		for displayID, required in pairs(loadData.Displays) do
			if(self:HasAuraDisplay(displayID)) then
				local display = self:GetAuraDisplay(displayID);
				local dep = display["Actions"]["DisplayActivate"];
				if(dep) then
					temp2[dep] = (required or id ~= dep or nil);
				end
			end
		end
		-- Work on the provider dependencies.
		for provID, _ in pairs(loadData.Providers) do
			local prov = self:GetAuraProvider(provID);
			-- Get the provider class.
			for int, svc in pairs(prov) do
				local c = self:GetServiceClassImplementation(svc["Type"], int);
				local deps = c:GetActionDependencies(svc["Parameters"]);
				if(deps) then
					for dep, required in pairs(deps) do
						temp2[dep] = (required or id ~= dep or nil);
					end
				end
			end
		end
		-- Return the table.
		return temp2;
	end

	--- Loads all actions into the dispatcher.
	-- @param self The PowerAuras table reference.
	local function LoadActions(self)
		-- Actions are picky and have complex dependency rules summed up by
		-- this: If it ain't loaded, it ain't there, so it ain't valid.
		local count = 0;
		for id, action in pairs(self:GetLoadedActions()) do
			-- Action => Data, ID => Data. Data is a single table reference.
			local data = ResourceDataClass("State", "Timed", "Types",
				"ActionDeps", "ProviderDeps", "ID", "Instance", "Triggers");
			DispatcherActionsData[action] = data;
			DispatcherActionIDsData[id] = data;
			-- Update the lists/flags in the data.
			local loadData = self:GetLoadedActionData(id);
			self:ListKeys(loadData.Types, data.Types);
			data.ID = id;
			data.Instance = action;
			data.Timed = loadData.Timed;
			data.State = false;
			-- Create subtables for triggers.
			for i = 1, #(loadData.Lazy) do
				data.Triggers[i] = ResourceDataClass("Timed", "Store");
				data.Triggers[i].Timed = loadData.PerTimed[i];
				data.Triggers[i].Store = loadData.Stores[i];
			end
			-- Increment counter and use temp table for dependency tracking.
			count = count + 1;
			-- Get the real dependency count.
			local deps = GetActionDependencies(self, id);
			if(deps) then
				temp[action] = self:CountPairs(deps);
			else
				temp[action] = 2^31 - 1;
			end
		end
		-- Resolve display/provider dependency issues.
		local action, data = next(DispatcherActionsData);
		while(action) do
			local id = data.ID;
			local loadData = self:GetLoadedActionData(id);
			-- Iterate over required displays.
			local isValid = true;
			for dep, _ in pairs(loadData.Displays) do
				-- Registered?
				if(not DispatcherDisplayIDsData[dep]) then
					-- Failure.
					
-- self:PrintError("        Display failed: %d", dep);
					isValid = false;
					break;
				else
-- self:PrintSuccess("        Display passed: %d", dep);
				end
			end
			-- Repeat for providers.
			if(isValid) then
				for dep, _ in pairs(loadData.Providers) do
					if(not DispatcherProviderIDsData[dep]) then
-- self:PrintError("        Provider failed: %d", dep);
						isValid = false;
						break;
					else
-- self:PrintSuccess("        Provider passed: %d", dep);
					end
				end
			end
			-- Repeat for our action target.
			if(isValid and type(loadData.Target) == "number") then
				local target = loadData.Target;
				local targetType = bit.rshift(target, 16);
				local dep = bit.band(target, 0xFFFF);
				if(targetType == 1) then
					-- Targetting a display, ensure loaded.
					if(not DispatcherDisplayIDsData[dep]) then
-- self:PrintError("        Target Display failed: %d", dep);
						isValid = false;
					else
-- self:PrintSuccess("        Target Display passed: %d", dep);
					end
				else
					-- Unknown target.
					self:PrintError("Unknown action target: %d", target);
					isValid = false;
				end
			end
			-- Remained valid?
			if(isValid) then
				-- Re-iterate and add this action to all the displays.
-- self:PrintInfo("        Result: |cFF00FF00Passed");
				for dep, _ in pairs(loadData.Displays) do
					tinsert(DispatcherDisplayIDsData[dep].ActionDeps, action);
				end
				-- In addition, connect this action to any providers that
				-- our triggers depend upon.
				for dep, _ in pairs(loadData.Providers) do
					tinsert(DispatcherProviderIDsData[dep].ActionDeps, action);
				end
			else
				-- Failed, so remove this action from the dispatcher.
				DispatcherActionsData[action] = nil;
				DispatcherActionIDsData[id] = nil;
				temp[action] = nil;
-- self:PrintInfo("        Result: |cFFFF0000Failed");
			end
			-- Next!
			action, data = next(DispatcherActionsData, action);
		end
		-- Resolve action dependency issues.
-- self:PrintInfo("Actions Stage 3:");
		local resolved = 0;
		repeat
			local delta = 0;
-- self:PrintInfo("    Begin pass:");
			-- Find an action with no unresolved dependencies.
			for action, data in pairs(DispatcherActionsData) do
				-- Get action data tables.
				local id = data.ID;
				local loadData = self:GetLoadedActionData(id);
				if(temp[action] == 0) then
-- self:PrintInfo("        Action: %d (%d/%d remaining)", id, temp[action], self:CountPairs(GetActionDependencies(self, id)));
-- self:PrintInfo("            Result: |cFF00FF00Resolved");
					-- Properly increment resolution counters.
					delta = delta + 1;
					resolved = resolved + 1;
					-- Remove action from temp table, add to list.
					temp[action] = nil;
					tinsert(DispatcherActionsList, action);
					-- Find actions which depend on this one.
					for subAction, subData in pairs(DispatcherActionsData) do
						local subID = subData.ID;
						local subDeps = GetActionDependencies(self, subID);
						-- Action dependency exists?
						if(subDeps[id] and temp[subAction]) then
							-- Add this depender to our data table.
							tinsert(data.ActionDeps, subAction);
							-- Decrement remaning dependency count.
							temp[subAction] = temp[subAction] - 1;
						end
					end
				elseif(temp[action]) then
-- self:PrintInfo("        Action: %d (%d/%d remaining)", id, temp[action], self:CountPairs(GetActionDependencies(self, id)));
-- self:PrintInfo("            Result: |cFFFFD200Deferred");
				end
			end
-- self:PrintInfo("    End pass: %d/%d (%d) resolved", resolved, count, delta);
		until(delta == 0 or resolved >= count);
		-- Any resolution issues?
		if(resolved ~= count) then
-- self:PrintError("Actions Stage 3 (Errors):");
			-- Iterate over remaining unresolved actions.
			for action, count in pairs(temp) do
				-- Remove from the registry.
				local id = self:GetLoadedActionID(action);

-- local loadData = self:GetLoadedActionData(id);
-- self:PrintError("    Action: %d (%d/%d unresolved)", id, count, self:CountPairs(GetActionDependencies(self, id)));

				DispatcherActionsData[action] = nil;
				DispatcherActionIDsData[id] = nil;
				-- Remove references from all providers/displays. This isn't
				-- fast, but this is an error condition so speed is irrelevant.
				for id, data in pairs(DispatcherDisplayIDsData) do
					for i = #(data.ActionDeps), 1, -1 do
						if(data.ActionDeps[i] == action) then
-- self:PrintInfo("        Removed from Display: %d", id);
							tremove(data.ActionDeps, i);
							break;
						end
					end
				end
				for id, data in pairs(DispatcherProviderIDsData) do
					for i = #(data.ActionDeps), 1, -1 do
						if(data.ActionDeps[i] == action) then
-- self:PrintInfo("        Removed from Provider: %d", id);
							tremove(data.ActionDeps, i);
							break;
						end
					end
				end
			end
		end
		-- Clean the temporary table.
		wipe(temp);
		wipe(temp2);
-- self:PrintSuccess("Actions registered!");
	end

	--- Loads all displays into the dispatcher.
	-- @param self The PowerAuras table reference.
	local function LoadDisplays(self)
-- self:PrintInfo("Displays Stage 1:");
		-- Create data tables for the displays.
		local count = 0;
		for id, display in pairs(self:GetLoadedDisplays()) do
			-- Check to see if the layouts/providers of this display exist.
			local vars = self:GetAuraDisplay(id);
			if(self:IsLayoutLoaded(vars["Layout"]["ID"])
				and (not vars["Provider"]
					or DispatcherProviderIDsData[vars["Provider"]])) then
-- self:PrintInfo("    Display: %d", id);
-- self:PrintInfo("        Result: |cFF00FF00Passed");
				-- Everything exists.
				local data = ResourceDataClass("State", "ActionDeps");
				data.State = PowerAuras.DisplayStates["Hide"];
				DispatcherDisplaysData[display] = data;
				DispatcherDisplayIDsData[id] = data;
				temp[display] = false;
				count = count + 1;
			else
-- self:PrintInfo("    Display: %d", id);
-- self:PrintInfo("        Result: |cFFFF0000Failed");
			end
		end
		-- Iterate until all display parents are resolved.
-- self:PrintInfo("Displays Stage 2:");
		local resolved, displays = 0, self:GetLoadedDisplays();
		repeat
-- self:PrintInfo("    Begin pass:");
			-- Iterate over displays.
			local delta = 0;
			for id, display in pairs(displays) do
				-- Get the saved var data for this display.
				local vars = self:GetAuraDisplay(id);
				-- Check the parent of the display.
				local layout = PowerAuras:GetLayout(vars["Layout"]["ID"]);
				local class = PowerAuras:GetLayoutClass(layout["Type"]);
				local parent = class:GetParentDisplay(id);
				local frame = parent and self:GetLoadedDisplay(parent);
				if((not parent or temp[frame]) and not temp[display]) then
					-- Valid, either we processed it or there is none!
-- self:PrintInfo("        Display: %d", id);
-- self:PrintInfo("            Result: |cFF00FF00Resolved");
					delta = delta + 1;
					resolved = resolved + 1;
					temp[display] = true;
					-- And now register the display with its layout.
					local l = self:GetLoadedLayout(vars["Layout"]["ID"]);
					l:RegisterDisplay(display, vars["Layout"]["Parameters"]);
					-- Register the display with the provider.
					if(vars["Provider"] and display.OnProviderUpdate) then
						local p = DispatcherProviderIDsData[vars["Provider"]];
						tinsert(p.ResourceDeps, display);
						-- Same with the layout.
						if(not tContains(p.ResourceDeps, l)) then
							tinsert(p.ResourceDeps, l);
						end
					end
				elseif(not temp[display]) then
-- self:PrintInfo("        Display: %d", id);
-- self:PrintInfo("            Result: |cFFFFD200Deferred");
				end
			end
-- self:PrintInfo("    End pass: %d/%d (%d) resolved", resolved, count, delta);
		until(delta == 0 or resolved >= count);
		-- Any resolution issues?
		if(resolved ~= count) then
-- self:PrintError("Displays Stage 3 (Errors):");
			-- Iterate over loaded displays.
			for id, display in pairs(self:GetLoadedDisplays()) do
				if(not temp[state]) then
					-- Failed to register, remove it.
-- self:PrintError("    Display: %d", id);
					DispatcherDisplaysData[display] = nil;
					DispatcherDisplayIDsData[id] = nil;
				end
			end
		end
		-- Clean the temporary table.
		wipe(temp);
-- self:PrintSuccess("Displays registered!");
	end

	--- Constructs the event handler function.
	-- @param self The PowerAuras table reference.
	local function LoadEvents(self)
-- self:PrintInfo("Events Stage 1:");
		-- Get a list of the required events to listen to.
		for id, _ in pairs(DispatcherActionIDsData) do
			local loadData = self:GetLoadedActionData(id);
			-- Iterate over classes and determine the events.
			for name, _ in pairs(loadData.Classes) do
				local class = self:GetTriggerClass(name);
				for event, filter in pairs(class:GetEventFilters()) do
-- if(temp[event] == nil) then
-- self:PrintInfo("    Detected event (action): %s (%s)", event, type(filter));
-- end
					temp[event] = temp[event] or (type(filter) == "function");
				end
			end
		end
		-- Repeat for providers.
		for id, _ in pairs(DispatcherProviderIDsData) do
			local vars = self:GetAuraProvider(id);
			-- Iterate over the services/sources/whatever.
			for int, svc in pairs(vars) do
				local c = self:GetServiceClassImplementation(svc["Type"], int);
				for event, filter in pairs(c:GetEventFilters()) do
					-- Flag the event.
-- if(temp[event] == nil) then
-- self:PrintInfo("    Detected event (provider): %s", event);
-- end
					temp[event] = true;
				end
			end
		end
-- self:PrintInfo("Events Stage 2:");
		-- Run over the detected events, this time find the ones that
		-- directly referenced trigger types (not functions).
		local event, state = next(temp);
		while(event) do
			if(not state) then
				-- Run over all the classes again and find references to
				-- this event.
				local isValid = false;
				for id, _ in pairs(DispatcherActionIDsData) do
					local loadData = self:GetLoadedActionData(id);
					for name, _ in pairs(loadData.Classes) do
						local class = self:GetTriggerClass(name);
						-- Does this action contain a trigger type that
						-- matches the filter?
						local events = class:GetEventFilters();
						local filter = events[event];
						if(loadData.Types[filter]) then
							isValid = true;
							break;
						elseif(type(filter) == "table") then
							-- Check for a match within the filter.
							for i = 1, #(filter) do
								if(loadData.Types[filter[i]]) then
									isValid = true;
									break;
								end
							end
						end
					end
					-- Break early if possible.
					if(isValid) then
						break;
					end
				end
				-- Did the event remain invalid (is it not used?)
				if(not isValid) then
					-- Remove it, then.
					temp[event] = nil;
-- self:PrintInfo("    Filtered event: %s", event);
				end
			end
			event, state = next(temp, event);
		end
-- self:PrintInfo("Events Stage 3:");
		-- Clear the filter lists.
		local filters = EventFilters;
		wipe(filters);
		-- Build the filter lists now.
		for event, _ in pairs(temp) do
			-- Create the filter table.
			filters[event] = {};
			local filters = filters[event];
			wipe(temp2);
			-- Set up some offsets for our filter types.
			local trig, act, prov, cust = 5, 5, 5, 5;
			filters[1], filters[2], filters[3], filters[4] = 0, 0, 0, 0;
			-- Find our flaggable resources from this event. Actions first.
			for id, _ in pairs(DispatcherActionIDsData) do
				local loadData = self:GetLoadedActionData(id);
				for name, _ in pairs(loadData.Classes) do
					local class = self:GetTriggerClass(name);
					local events = class:GetEventFilters();
					local filter = events[event];
					if(filter) then
						-- What type of filter?
						local action = self:GetLoadedAction(id);
						if(type(filter) == "string") then
							-- Trigger type. Have we flagged the type?
							if(not temp2[filter]) then
								tinsert(filters, trig, filter);
								-- Increment counters.
								act, prov, cust = act + 1, prov + 1, cust + 1;
							end
							-- Flag the action too.
							tinsert(filters, act, action);
							prov, cust = prov + 1, cust + 1;
						elseif(type(filter) == "table") then
							-- Collection of trigger types.
							for i = 1, #(filter) do
								local item = filter[i];
								-- Flagged yet?
								if(not temp2[item]) then
									tinsert(filters, trig, item);
									act, prov, cust =
										act + 1, prov + 1, cust + 1;
								end
								-- Flag the action.
								tinsert(filters, act, action);
								prov, cust = prov + 1, cust + 1;
							end
						elseif(type(filter) == "function") then
							-- Function.
							tinsert(filters, cust, filter);
						end
					end
				end
			end
			-- Move on to providers.
			for id, _ in pairs(DispatcherProviderIDsData) do
				local vars = self:GetAuraProvider(id);
				for i, s in pairs(vars) do
					local c = self:GetServiceClassImplementation(s["Type"], i);
					local events = c:GetEventFilters();
					if(events[event]) then
						-- Event is being filtered. Flag the provider.
						tinsert(filters, prov, self:GetLoadedProvider(id));
						cust = cust + 1;
					end
				end
			end
			-- Add the counters to the table.
			filters[1], filters[2], filters[3], filters[4] = 
				trig, act, prov, cust;
		end
-- self:PrintInfo("Events Stage 4:");
		-- Register the events.
		self.Frame:UnregisterAllEvents();
		for event, _ in pairs(temp) do
-- self:PrintInfo("    Registered event: %s", event);
			self.Frame:RegisterEvent(event);
		end
		-- Set the script.
		self.Frame:SetScript("OnEvent", OnEvent);
		-- Clean the temporary tables.
		wipe(temp);
		wipe(temp2);
-- self:PrintSuccess("Events registered!");
	end

	--- Loads all providers into the dispatcher.
	-- @param self The PowerAuras table reference.
	local function LoadProviders(self)
-- self:PrintInfo("Providers Stage 1:");
		-- Providers can have dependencies, but they aren't enforced until
		-- we load actions (as actions control these dependencies). As such
		-- a provider with a broken dependency is merely broken, but valid.
		for id, prov in pairs(self:GetLoadedProviders()) do
			-- Provider => Data, ID => Data. Data is a single table reference.
-- self:PrintInfo("    Provider %d: |cFF00FF00Registered", id);
			local data = ResourceDataClass("ResourceDeps", "ActionDeps", 
				"ID", "Instance");
			data.ID = id;
			data.Instance = prov;
			DispatcherProvidersData[prov] = data;
			DispatcherProviderIDsData[id] = data;
			tinsert(DispatcherProvidersList, prov);
		end
-- self:PrintSuccess("Providers registered!");
	end

	--- Loads the dispatcher, registering all resources, validating
	--  dependencies and creating the event handler.
	function PowerAuras:LoadDispatcher()
-- self:PrintInfo("Loading dispatcher...");
		-- Unload if loaded.
		if(DispatcherLoaded) then
			self:UnloadDispatcher();
		end
		-- Begin with providers.
		LoadProviders(self);
		-- Move on to displays and layouts.
		LoadDisplays(self);
		-- Now work with actions, create relevant resources.
		LoadActions(self);
		-- Ensure providers are updated when their dependant actions
		-- undergo a state change. This is done now because the actions are
		-- the last things to be registered due to their dependency systems.
		for id, _ in pairs(DispatcherProviderIDsData) do
			-- Get provider.
			local p = self:GetLoadedProvider(id);
			local vars = self:GetAuraProvider(id);
			-- Get the provider class.
			for int, svc in pairs(vars) do
				local c = self:GetServiceClassImplementation(svc["Type"], int);
				local deps = c:GetActionDependencies(svc["Parameters"]);
				if(deps) then
					for dep, _ in pairs(deps) do
						-- Add to data table if the dependency has been
						-- properly registered. Note that if it hasn't, any
						-- actions which need this provider will have failed to
						-- load already, so this is safe!
						local data = DispatcherActionIDsData[dep];
						if(data and not tContains(data.ProviderDeps, p)) then
							tinsert(data.ProviderDeps, p);
						end
					end
				end
			end
		end
		-- Finally, build the event handler.
		LoadEvents(self);
		-- Flag as loaded.
		self.Frame:SetScript("OnUpdate", OnUpdate);
		DispatcherLoaded = true;
		self:ResetBuffers();
-- self:PrintSuccess("Dispatcher loaded!");
	end
end

--- Resets all buffer states. No swapping is performed.
function PowerAuras:ResetBuffers()
	-- Reset all buffers.
	wipe(DelayTypes);
	for i = 1, PowerAuras.MAX_STATE_BUFFERS do
		BuffersByFrame[i]:Reset();
	end
	-- Mark everything for rechecks.
	for i = 1, #(DispatcherActionsList) do
		BuffersByFrame[1].Actions[DispatcherActionsList[i]] = true;
	end
	for i = 1, #(DispatcherProvidersList) do
		BuffersByFrame[1].Providers[DispatcherProvidersList[i]] = true;
	end
	-- Flag all trigger types, thanks to the wonder of lazy triggers.
	for i = 1, #(DispatcherActionsList) do
		local id = self:GetLoadedActionID(DispatcherActionsList[i]);
		local loadData = self:GetLoadedActionData(id);
		-- Flag all types.
		for trig, _ in pairs(loadData.Types) do
			BuffersByFrame[1].Triggers[trig] = true;
		end
	end
end

--- Marks all providers that depend upon the specified action.
-- @param id The ID of the action.
function PowerAuras:MarkActionDependentProviders(id)
	-- Get the action data.
	local data = DispatcherActionIDsData[id];
	-- Mark the providers.
	local providers = BuffersByFrame[1].Providers;
	local actions = BuffersByFrame[1].Actions;
	for i = 1, #(data.ProviderDeps) do
		local prov = data.ProviderDeps[i];
		providers[prov] = true;
		-- In addition, flag actions that require this provider.
		local data = DispatcherProvidersData[prov];
		for i = 1, #(data.ActionDeps) do
			actions[data.ActionDeps[i]] = true;
		end
	end
end

--- Marks a trigger type for rechecking.
-- @param type      The trigger type to be rechecked.
-- @param immediate If true, the recheck will be applied to the current update
--                  event buffer. This should normally be left as nil/false,
--                  which will defer the check to the next buffer swap.
function PowerAuras:MarkTriggerType(type, immediate)
	BuffersByFrame[immediate and 1 or 2].Triggers[type] = true;
end

--- Marks an action for rechecking.
-- @param action    The action function to be rechecked.
-- @param immediate If true, the recheck will be applied to the current update
--                  event buffer. This should normally be left as nil/false,
--                  which will defer the check to the next buffer swap.
function PowerAuras:MarkAction(action, immediate)
	-- Flag the action.
	local buffer = BuffersByFrame[immediate and 1 or 2];
	buffer.Actions[action] = true;
	-- Flag the trigger types too, otherwise lazy evaluation may cause issues.
	local data = self:GetLoadedActionData(self:GetLoadedActionID(action));
	for type, _ in pairs(data.Types) do
		buffer.Triggers[type] = true;
	end
end

--- Marks an action (by ID) for rechecking.
-- @param id        The action ID to be rechecked.
-- @param immediate If true, the recheck will be applied to the current update
--                  event buffer. This should normally be left as nil/false,
--                  which will defer the check to the next buffer swap.
function PowerAuras:MarkActionID(id, immediate)
	return self:MarkAction(self:GetLoadedAction(id), immediate);
end

--- Marks a provider for an updat.e
-- @param id        The ID of the provider.
-- @param immediate If true, the provider is flagged immediately.
function PowerAuras:MarkProvider(id, immediate)
	-- Get and flag the provider.
	local data = DispatcherProviderIDsData[id];
	local buffer = BuffersByFrame[immediate and 1 or 2];
	buffer.Providers[data.Instance] = true;
	-- Flag action dependencies.
	for i = 1, #(data.ActionDeps) do
		buffer.Actions[data.ActionDeps[i]] = true;
	end
end

--- Sets a delay for rechecking an action.
-- @param actionID The ID of the action to delay a recheck for.
-- @param delay    The delay in seconds, if set to 0 this will clear any delay.
function PowerAuras:SetActionDelay(actionID, delay)
	local data = DispatcherActionIDsData[actionID];
	if(data) then
		data.Delay = (delay > 0 and GetTime() + delay);
	end
end

--- Sets the currently active sequence of an action.
-- @param id       The ID of the action.
-- @param sequence The active sequence index, or nil if none is active.
function PowerAuras:SetActionActivationData(id, sequence)
	-- Get existing data.
	local data = DispatcherActionIDsData[id];
	if(not data) then
		return;
	end
	if(sequence and not data.State) then
		-- We were previously inactive and just turned on.
		data.State = true;
		data.Time = GetTime();
		data.Sequence = sequence;
	elseif(sequence and data.State and sequence ~= data.Sequence) then
		-- We were previously active and just changed sequence.
		data.Sequence = sequence;
	elseif(not sequence and data.State) then
		-- We were previously active and just turned off.
		data.State = false;
		data.Time = nil;
		data.Sequence = nil;
	else
		-- Nothing notable has changed.
		return;
	end
	-- As our action just had a state change, flag its dependencies.
	local actions = BuffersByFrame[1].Actions;
	for i = 1, #(data.ActionDeps) do
		actions[data.ActionDeps[i]] = true;
	end
	local providers = BuffersByFrame[1].Providers;
	for i = 1, #(data.ProviderDeps) do
		local prov = data.ProviderDeps[i];
		providers[prov] = true;
		-- In addition, flag actions that require this provider.
		local data = DispatcherProvidersData[prov];
		for i = 1, #(data.ActionDeps) do
			actions[data.ActionDeps[i]] = true;
		end
	end
end

--- Sets the activation state for a display.
-- @param id    The ID of the display.
-- @param state The state to set.
-- @param async Pass as true if the state is being set from a source
--              outside of an action (such as an animation). This will
--              correctly defer dependency rechecks by a frame if needed.
function PowerAuras:SetDisplayActivationData(id, state, async)
	-- Get existing data.
	local data = DispatcherDisplayIDsData[id];
	if(not data) then
		return;
	end
	-- Assume our state changed.
	state = PowerAuras.DisplayStates[state] or 0;
	if(data.State == state) then
		return;
	else
		data.State = state;
	end
	-- Flag dependent resources ASAP.
	local bufNow, bufNext = BuffersByFrame[1], BuffersByFrame[2];
	local actionBuffer = bufNow;
	if(actionBuffer.ActionProgress > 1 and async) then
		actionBuffer = bufNext;
	end
	-- Flag actions.
	local actions = actionBuffer.Actions;
	for i = 1, #(data.ActionDeps) do
		actions[data.ActionDeps[i]] = true;
	end
end

--- Sets the edit mode state of the addon. Correctly disables/enables the
--  systems of the dispatcher and unloads/loads resources based on the state.
-- @param state True to enable editing mode, false to disable.
function PowerAuras:SetEditMode(state)
	-- Update the state.
	EditMode = state;
	if(state) then
		-- Detach scripts.
		self.Frame:SetScript("OnEvent", nil);
		self.Frame:SetScript("OnUpdate", nil);
		-- Force all actions to disable themselves safely.
		for i = 1, #(DispatcherActionsList) do
			local id = self:GetLoadedActionID(DispatcherActionsList[i]);
			local data = self:GetLoadedActionData(id);
			local old = self:GetActionActivationSequence(id);
			-- Forcefully disable by calling the activator directly.
			data["Activator"](nil, old);
			-- Ensure our data tables align with this state change.
			self:SetActionActivationData(id, nil);
		end
		-- "Unload" the profile (this is safe!).
		self:UnloadProfile();
		-- Fire callbacks.
		self.OnOptionsEvent("EDIT_MODE", true);
	else
		-- Reload the profile.
		self.OnOptionsEvent("EDIT_MODE", false);
		self:LoadCustomTriggers();
		self:LoadProfile(self:GetCurrentProfileID());
		self:ResetBuffers();
	end
end

--- Updates the timed recheck flag of a trigger.
-- @param id    The ID of the action.
-- @param index The index of the trigger.
-- @param state The state to set.
-- @remarks This function is fairly slow, so calling it often is ill-advised.
function PowerAuras:SetTriggerTimed(id, index, state)
	-- Get the dispatcher data for this action.
	local data = DispatcherActionIDsData[id];

	-- If the states match, don't bother.
	if(data.Timed == state) then
		return;
	end

	-- Otherwise, update our overall state.
	data.Timed = state;
	local triggers = data.Triggers;
	triggers[index].Timed = state;

	-- If false, search for timed ones.
	if(not data.Timed) then
		for i = 1, #(triggers) do
			if(triggers[i].Timed) then
				-- Got it, break out.
				data.Timed = true;
				break;
			end
		end
	end
end

--- Sets a delay for rechecking a trigger type.
-- @param type  The trigger type to delay checks for.
-- @param delay The delay in seconds, if set to 0 this will clear any delay.
function PowerAuras:SetTriggerTypeDelay(type, delay)
	DelayTypes[type] = (delay > 0 and GetTime() + delay or nil);
end

--- Swaps the buffer states, cycling to the next one.
function PowerAuras:SwapBuffers()
	-- Cycle the buffers.
	local buffer = tremove(BuffersByFrame, 1);
	buffer:Reset();
	tinsert(BuffersByFrame, buffer);
	-- Flag delayed triggers.
	local trigger, delay = next(DelayTypes);
	while(trigger) do
		if(delay <= buffer.Time) then
			buffer.Triggers[trigger] = true;
			DelayTypes[trigger] = nil;
		end
		trigger, delay = next(DelayTypes, trigger);
	end
end

--- Unloads the dispatcher, resetting lists and resources.
function PowerAuras:UnloadDispatcher()
	-- self:PrintInfo("Unloading dispatcher...");
	-- Disconnect displays from their layouts (important!).
	for id, _ in pairs(DispatcherDisplayIDsData) do
		-- Get the display.
		local display = self:GetLoadedDisplay(id);
		-- Disconnect it from the layout.
		local layoutID = self:GetAuraDisplay(id)["Layout"]["ID"];
		local layout = self:GetLoadedLayout(layoutID);
		layout:UnregisterDisplay(display);
	end
	-- Clear data tables.
	self:ResetBuffers();
	wipe(DispatcherActionIDsData);
	wipe(DispatcherActionsData);
	wipe(DispatcherActionsList);
	wipe(DispatcherDisplayIDsData);
	wipe(DispatcherDisplaysData);
	wipe(DispatcherProviderIDsData);
	wipe(DispatcherProvidersData);
	wipe(DispatcherProvidersList);
	wipe(EventFilters);
	-- Remove scripts, flag as not loaded.
	self.Frame:UnregisterAllEvents();
	self.Frame:SetScript("OnEvent", nil);
	self.Frame:SetScript("OnUpdate", nil);
	DispatcherLoaded = false;
end

-- Handle ADDON_LOADED event once.
PowerAuras.Frame:RegisterEvent("ADDON_LOADED");
--- Script handler for ADDON_LOADED. Loads all resources and then swaps to
--  the real event handler.
PowerAuras.Frame:SetScript("OnEvent", function(self, event, ...)
	-- Quit if irrelevent.
	if(event ~= "ADDON_LOADED" and ... ~= "PowerAuras") then
		return;
	end
	-- Unregister event.
	self:UnregisterEvent("ADDON_LOADED");
	-- Populate buffers.
	for i = 1, PowerAuras.MAX_STATE_BUFFERS do
		BuffersByFrame[i] = BufferStateClass();
	end
	EventBuffer = BuffersByFrame[1];
	-- Get the addon version.
	local version = GetAddOnMetadata("PowerAuras", "Version");
	PowerAuras.CurrentVersion = PowerAuras.Version(version);
	-- Iterate over all addons (yes, seriously).
	for i = 1, GetNumAddOns() do
		-- Find addons flagged as providing resources to us.
		if(GetAddOnMetadata(i, "X-PowerAuras-Plugin")) then
			-- Attempt to load it.
			local name, _, _, enabled, loadable, reason = GetAddOnInfo(i);
			local loaded = IsAddOnLoaded(i);
			if(not loaded and enabled and loadable) then
				loaded, reason = LoadAddOn(i);
			end
			-- Did it fail?
			if(not loaded and reason ~= "DISABLED") then
				-- Tell the user this plugin couldn't be loaded.
				PowerAuras:PrintError(
					L("ErrorPluginFailed", name, _G["ADDON_" .. reason])
				);
			end
		end
	end
	-- Validate all loaded classes.
	PowerAuras:ValidateResourceClasses();
	-- Deal with saved variables.
	local state, err = pcall(PowerAuras.LoadSavedVariables, PowerAuras);
	if(not state) then
		PowerAuras:PrintError("Error: %s", err);
	end
	PowerAuras.LastVersion = PowerAuras.Version(
		PowerAuras.GlobalSettings["LastVersion"]
	);
	-- Fire Loaded callback.
	PowerAuras:OnAddOnLoaded();
	PowerAuras.OnAddOnLoaded:Reset();
end);

--- Class-type definition for a buffer state. By default we have two of these.
--  Add any per-frame tables and data to this.
BufferStateClass = setmetatable({
	-- Event handling:
	LoggedEvents = {},  -- [ { Event, arguments }, ... ]
	TriggerEvents = setmetatable({}, {
		--- __index metamethod for creating tables automatically.
		__index = function(t, k)
			t[k] = {};
			return t[k]
		end,
	}), -- { Trigger Type : [ { Event, arguments }, ... ] }
	IsEventLogged = false,
	-- Event handling cleanups and tracking:
	LoggedEventsCount = 0,
	TriggerEventStates = {}, -- { Trigger Type: State }
	-- Action/Trigger rechecks:
	Actions = {}, -- { Action : State }
	Triggers = {}, -- { Type : State }
	-- Provider rechecks:
	Providers = {}, -- { Provider : State }
	-- Update iteration progress:
	ActionProgress = 1,
	ProviderProgress = 1,
	-- Time storage (since last reset):
	Time = 0,
}, {
	__call = function(self)
		local new = PowerAuras:CopyTable(self);
		-- Apply metatable to TriggerEvents.
		setmetatable(new.TriggerEvents, getmetatable(self.TriggerEvents));
		return new;
	end,
});

--- Flags a single trigger type.
-- @param type The trigger type to mark.
function BufferStateClass:FlagTrigger(type)
	self.Triggers[type] = true;
end

--- Flags multiple trigger types.
-- @param ... The trigger types to mark.
function BufferStateClass:FlagTriggers(...)
	-- Upvalues to reduce table lookups.
	local triggers = self.Triggers;
	-- Iterate over types.
	for i = 1, select("#", ...) do
		triggers[select(i, ...)] = true;
	end
end

--- Logs the current event, allowing LogTrigger/LogTriggers to be called.
-- @param ... The event name and arguments to store.
-- @remarks This should be called once in an event handler before using
--          LogTrigger(s). Failing to do so will cause strange behaviour.
function BufferStateClass:LogEvent(...)
	-- No logging is needed if we've already done it for this event.
	if(self.IsEventLogged) then
		return;
	end
	self.IsEventLogged = true;
	-- Store the event in a table.
	local t = TableStore:remove() or {};
	for i = 1, select("#", ...) do
		t[i] = select(i, ...);
	end
	-- Store within the logged events list.
	self.LoggedEventsCount = self.LoggedEventsCount + 1;
	self.LoggedEvents[self.LoggedEventsCount] = t;
end

--- Flags and logs the current event for a single trigger.
-- @param type The trigger type to mark.
-- @remarks Ensure LogEvent is called once before calling this function.
function BufferStateClass:LogTrigger(type)
	-- Flag the trigger.
	self.Triggers[type] = true;
	-- Clean the event store for this trigger if needed.
	local events = self.TriggerEvents[type];
	local states = self.TriggerEventStates;
	if(not states[type]) then
		states[type] = true;
		wipe(events);
	end
	-- Store the event reference.
	events[#(events) + 1] = self.LoggedEvents[self.LoggedEventsCount];
end

--- Flags and logs the current event for multiple triggers.
-- @param ... The trigger types to mark.
-- @remarks Ensure LogEvent is called once before calling this function.
function BufferStateClass:LogTriggers(...)
	-- Upvalues to reduce table lookups.
	local eventData = self.LoggedEvents[self.LoggedEventsCount];
	local events = self.TriggerEvents[type];
	local states = self.TriggerEventStates;
	local triggers = self.Triggers;
	-- Iterate over types.
	for i = 1, select("#", ...) do
		-- Flag the trigger.
		local type = select(i, ...);
		triggers[type] = true;
		-- Clean the event store for this trigger if needed.
		if(not states[type]) then
			states[type] = true;
			wipe(events);
		end
		-- Store the event reference.
		events[#(events) + 1] = eventData;
	end
end

--- Resets the buffer state, clearing the necessary tables.
function BufferStateClass:Reset()
	-- Don't forget to wipe!
	wipe(self.Actions);
	wipe(self.Providers);
	wipe(self.TriggerEventStates);
	wipe(self.Triggers);
	-- Recycle logged events.
	for i = self.LoggedEventsCount, 1, -1 do
		local t = self.LoggedEvents[i];
		TableStore:insert(wipe(t));
	end
	-- Reset progress.
	self.LoggedEventsCount = 0;
	self.ActionProgress = 1;
	self.ProviderProgress = 1;
	self.IsEventLogged = false;
	self.Time = GetTime();
end

--- Standard class for holding resource data for the dispatcher.
ResourceDataClass = setmetatable({
	-- Resource data.
	ID = nil,
	Instance = nil,
	-- Activation data.
	State = nil,
	Sequence = nil,
	Time = nil,
	-- Dispatcher update data.
	Timed = false,
	Delay = nil,
	Types = {}, -- [ Resource subtypes, ... ]
	-- Trigger-specific stuff.
	Triggers = {}, -- [ Per-trigger data, ... ]
	Store = nil, -- Per-trigger table store.
	-- Dependency flagging.
	ActionDeps = {}, -- [ Actions, ... ]
	ProviderDeps = {}, -- [ Providers, ... ]
	ResourceDeps = {}, -- [ Resources, ... ]
}, {
	__call = function(self, ...)
		-- Slightly smarter copy system for the sake of memory efficiency.
		local argCount = select("#", ...);
		if(argCount == 0) then
			-- No arguments means do a full copy.
			return PowerAuras:CopyTable(self);
		else
			-- Otherwise, only copy over that which is needed.
			local copy = {};
			for i = 1, argCount do
				local k = select(i, ...);
				copy[k] = (type(self[k]) == "table" and {} or self[k]);
			end
			return copy;
		end
	end,
});